# React 基础
## react 哲学
1. 将设计好的 UI 划分为组件层级
   - 单一功能原则：一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。
2. 用 React 创建一个静态版本：
   - 将渲染 UI 和添加交互这两个过程分开
   - 编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节，**不应使用state**。添加交互功能时则要考虑大量细节，而不需要编写太多代码
   - 当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。
3. 确定 UI state 的最小（且完整）表示
   - 首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。
   - 检查传入数据是否为state
     - 该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。
     - 该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。
     - 你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。
4. 确定 state 放置的位置：判断哪个组件拥有这些state
  - 找到根据这个 state 进行渲染的所有组件。
  - 找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。
  - 该共同所有者组件或者比它层级更高的组件应该拥有该 state。
  - 如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。
5. 添加反向数据流
   - React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。
# 基本概念
## 常用技术
### 组件间通信
- <a src="https://segmentfault.com/a/1190000023585646">参考</a>
- 父组件 => 子组件：
  - Props
  - Instance Methods
- 子组件 => 父组件：
  - Callback Functions
  - Event Bubbling
- 兄弟组件之间：
  - Parent Component
- 不太相关的组件之间：
  - Context
  - Portals
  - Global Variables
  - Observer Pattern
  - Redux等
## 概念区别
### state 和 props 之间的区别是什么？
- props（“properties” 的缩写）和 state 都是普通的 JavaScript 对象。它们都是用来保存信息的，这些信息可以控制组件的渲染输出
- props 是传递给组件的（类似于函数的形参），而 state 是在组件内被组件自己管理的
# 常用库
## HOOK
## Redux
### 概念
- Redux 是 JavaScript 应用的状态容器，提供可预测的状态管理。
- 应用的整体全局状态以对象树的方式存放于单个 store。 唯一改变状态树（state tree）的方法是创建 action，一个描述发生了什么的对象，并将其 dispatch 给 store。 要指定状态树如何响应 action 来进行更新，你可以编写纯 reducer 函数，这些函数根据旧 state 和 action 来计算新 state。
## React Router
### 常用组件
- <a src="https://juejin.cn/post/6844904031857410062">参考</a>
- 路由组件（作为根组件）: BrowserRouter（history模式） 和 HashRouter（hash模式）
- 路径匹配组件: Route 和 Switch
- 导航组件: Link 和 NavLink
- 关于路由组件，如果我们的应用有服务器响应web的请求，建议使用`<BrowserRouter>`组件; 如果使用静态文件服务器，建议使用`<HashRouter>`组件
## GraphQL
### 概念
- GraphQL 是一种面向数据的 API 查询风格。
- 传统的 API 拿到的是前后端约定好的数据格式，GraphQL 对 API 中的数据提供了一套易于理解的完整描述，客户端能够准确地获得它需要的数据，没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。
# React 哲学
## 官方文档
- **第一步：将设计好的 UI 划分为组件层级**
  - 单一组件原则：一个组件原则上只能负责一个功能。如果它需要负责更多的功能，这时候就应该考虑将它拆分成更小的组件。
  - 信息结构：如果你的模型设计得恰当，UI（或者说组件结构）便会与数据模型一一对应
- **第二步：用 React 创建一个静态版本（组件库）**
  - 最好将渲染 UI 和添加交互这两个过程分开。
    - 编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；
    - 添加交互功能时则要考虑大量细节，而不需要编写太多代码。
  - 通过 props 传入所需的数据
    - 完全不应该使用 state 构建静态版本。
    - state 代表了随时间会产生变化的数据，应当仅在实现交互时使用。所以构建应用的静态版本时，你不会用到它。
  - 可以自上而下或者自下而上构建应用
    - 当你的应用比较简单时，使用自上而下的方式更方便；
    - 对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。
- **第三步：确定 UI state 的最小（且完整）表示**
  - 只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。
  - 逐个检查相应数据是否属于 state：
    1. 该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。
    2. 该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。
    3. 你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。
- **第四步：确定 state 放置的位置**
  - 
