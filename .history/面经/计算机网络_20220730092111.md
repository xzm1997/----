# 请求方法
## get、post区别及其优缺点
## 常见状态码
## 解释状态码304到200的过程？

# 认证与授权
## 概述
- 认证：验证当前用户的身份
- 授权：用户授予第三方应用访问该用户某些资源的权限就是授权
- 凭证：实现认证和授权的前提是需要一种媒介（证书） 来标记访问者的身份
- HTTP 是无状态的协议，对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息，每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人
- 服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。
## Cookie
- cookie 存储在客户端：cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。
- cookie 是不可跨域的： 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。
- cookie 重要的属性属性说明`name=value`键值对，设置 `Cookie` 的名称及相对应的值，都必须是字符串类型。
## Session
- session 是另一种记录服务器和客户端会话状态的机制
- session 是基于 `cookie` 实现的，`session` 存储在服务器端，`sessionId` 会被存储到客户端的 cookie 中
- session 认证流程：
  1. 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session
  2. 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器
  3. 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名
  4. 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。
- 根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。
- Cookie 和 Session 的区别
  - 安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。
  - 存取值的类型不同：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。
  - 有效期不同： Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。
  - 存储大小不同： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。
## Token 令牌
- 组成
  - uid: 用户唯一的身份标识
  - time: 当前时间的时间戳
  - sign: 签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串。
- 特点
  - 服务端无状态化
  - 可扩展性好
  - 支持移动端设备
  - 安全
  - 支持跨程序调用
- token 的身份验证流程
  1. 客户端使用用户名跟密码请求登录
  2. 服务端收到请求，去验证用户名与密码mitt
  3. 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
  4. 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里。客户端每次向服务端请求资源的时候需要带着服务端签发的 token
  5. 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据
- 每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里。基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库。token 完全由应用管理，所以它可以避开同源策略。
- Token和Session的区别
  - Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息
  - Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。
  - 所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。
## JWT
- JSON Web Token（简称 JWT）是目前最流行的跨域认证解决方案。是一种认证授权机制。
- 组成：它是一个很长的字符串，中间用点（.）分隔成三个部分。
  - Header（头部）：Header 部分是一个 JSON 对象，描述 JWT 的元数据
  - Payload（负载）：Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。
  - Signature（签名）：Signature 部分是对前两部分的签名，防止数据篡改。
- JWT 是为了在网络应用环境间传递声明而执行的一种基于 JSON 的开放标准（RFC 7519）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。
- JWT的认证流程：
  1. 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT
  2. 客户端将 token 保存到本地（通常使用 `localstorage`，也可以使用 `cookie`）
  3. 当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 `Authorization` 字段中使用 `Bearer` 模式添加 JWT，其内容看起来是下面这样 `Authorization: Bearer`
  4. 服务端的保护路由将会检查请求头 `Authorization` 中的 JWT 信息，如果合法，则允许用户的行为
- Token和JWT相同点：
  - 都是访问资源的令牌
  - 都可以记录用户的信息
  - 都是使服务端无状态化
  - 都是只有验证成功后，客户端才能访问服务端上受保护的资源
- `Token`和`JWT`不同点：
  - `Token`：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 `Token` 是否有效。
  - `JWT`：将 `Token` 和 `Payload` 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。
## 一些实用session，cookie，token，Jwt需要注意的问题
### 使用 cookie 时需要考虑的问题：
1. 因为存储在客户端，容易被客户端篡改，使用前需要验证合法性
2. 不要存储敏感数据，比如用户密码，账户余额, 使用 httpOnly 在一定程度上提高安全性, 尽量减少 cookie 的体积，能存储的数据量不能超过 `4kb`
3. 设置正确的 `domain` 和 `path`，减少数据传输
4. `cookie` 无法跨域
5. 一个浏览器针对一个网站最多存 20 个`Cookie`，浏览器一般只允许存放 300 个`Cookie`
6. 移动端对 `cookie` 的支持不是很好，而 `session` 需要基于 `cookie` 实现，所以移动端常用的是 token
### 使用 `session` 时需要考虑的问题：
1. 将 `session` 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session
2. 当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。
3. 多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。
4. sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？ 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现
5. 移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token
### 使用 token 时需要考虑的问题
1. 如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。
2. token 完全由应用管理，所以它可以避开同源策略
3. token 可以避免 CSRF 攻击(因为不需要 cookie 了)
### 使用 JWT 时需要考虑的问题：
1. 因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）
2. JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
3. JWT 不加密的情况下，不能将秘密数据写入 JWT。
4. JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
5. JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。
6. JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
7. JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。
8. 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输
### JWT伪造
- 安全问题
  - 修改算法为none
  - 修改算法从RS256到HS256
  - 信息泄漏 密钥泄漏
  - 爆破密钥
- 将web服务器返回的JWT数据进行翻译
- 使用工具爆破秘钥

# IP
## mac ip地址区别
- IP地址的设计是出于拓扑设计出来的，只要在不重复IP地址的情况下，它是可以随意更改的；而MAC地址是根据生产厂商烧录好的，它一般不能改动的
- 长度不同，IP地址的长度为32位，而MAC地址为48位。
- 寻址协议层不同
- 分配依据不同

# HTTP
- HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，“超文本”即不仅仅是文本，还可以传输HTML 文件, 图片文件等。
- HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。
- 主要特点
  - 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
  - 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
  - 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
  - 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
  - 支持B/S及C/S模式。
## URL
- 资源标识
  - URI（Uniform Resource Identifier，统一资源标识符）
  - URL（Uniform Resource Locator，统一资源定位符）
  - URN（Uniform Resource Name，统一资源名称）
- 组成
  - 协议部分
  - 域名部分
  - 端口部分
  - 虚拟目录部分
  - 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。
  - 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分
  - 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。
## HTTP 请求头 请求体 响应头 响应体 属性
- HTTP 请求报文由3部分组成(请求行+请求头+请求体)
 - 请求行：请求方法、URL、协议名称和版本号
 - 请求头：有若干个属性,形式为`key:val`,服务端据此获取客户端信息。包括可接受的内容、字符编码、能否压缩、浏览器支持的语言、浏览器要找的主机、缓存过期时间、请求来自哪里、浏览器内核、cookie、是否保持连接、请求时间
 - 请求体,它将一个页面表单中的组件值通过`param1=val1&parma=2`的键值对形式编码成一个格式化串,它承载多个请求参数的数据,不但报文头可以传递请求参数,URL也可以通过`/chapter15/user.html? param1=value1&param2=value2`的方式传递数值
- 响应报文与请求报文一样,由三个部分组成(响应行,响应头,响应体)
 - 响应行：报文协议及版本、状态码及状态描述
 - 响应头：怎么控制响应内容的缓存、请求资源的版本、重定向信息、设置客户端的cookie
## http状态码
- 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
- 101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。
- 200 (成功) 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
- 201 (已创建) 请求成功并且服务器创建了新的资源。
- 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。
- 205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。
- 206 (部分内容) 服务器成功处理了部分 GET 请求。
- 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
- 301 (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。
- 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
- 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
- 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
- 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
- 400 (错误请求) 服务器不理解请求的语法。
- 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403 (禁止) 服务器拒绝请求。
- 404 (未找到) 服务器找不到请求的网页。
- 410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。
- 500 (服务器内部错误) 服务器遇到错误，无法完成请求。
- 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。
- 505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。
## http方法
1. OPTIONS
  返回服务器针对特定资源所支持的HTTP请求方法，也可以利用向web服务器发送‘*’的请求来测试服务器的功能性
2. HEAD
  向服务器索与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以再不必传输整个响应内容的情况下，就可以获取包含在响应小消息头中的元信息。
3. GET
  向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在Web Application中，其中一个原因是GET可能会被网络蜘蛛等随意访问。Loadrunner中对应get请求函数：web_link和web_url
4. POST
  向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 Loadrunner中对应POST请求函数：web_submit_data,web_submit_form
5. PUT
  向指定资源位置上传其最新内容
6. DELETE
  请求服务器删除Request-URL所标识的资源
7. TRACE
  回显服务器收到的请求，主要用于测试或诊断
8. CONNECT
  HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
### GET请求的数据为什么会有长度限制
- Http get方法提交的数据大小长度并没有限制，Http协议规范没有对URL长度进行限制。
- 目前说的get长度有限制，是特定的浏览器及服务器对它的限制。
- 各种浏览器和服务器的最大处理能力如下：
  - IE：对URL的最大限制为2083个字符，若超出这个数字，提交按钮没有任何反应。
  - Firefox：对Firefox浏览器URL的长度限制为：65536个字符。
  - Safari：URL最大长度限制为80000个字符。
  - Opera：URL最大长度限制为190000个字符
  - Google(chrome)：URL最大长度限制为8182个字符。
  - Apache(Server)：能接受的最大url长度为8192个字符（这个准确度待定？？？）
  - Microsoft Internet Information Server(IIS)：n能接受最大url的长度为16384个字符。
- 理论上讲，post是没有大小限制的。Http协议规范也没有进行大小限制，起限制作用的是服务器处理程序的处理能力。
- Tomcat下默认post长度为2M，可通过修改conf/server.xml中的“maxPostSize=0”来取消对post大小的限制。
### GET VS POST扩展
- 多数浏览器对于POST采用两阶段发送数据的，先发送请求头，再发送请求体，即使参数再少再短，也会被分成两个步骤来发送（相对于GET）,也就是第一步发送header数据，第二部再发送body部分。Http是应用层的协议，而再传输层有些情况TCP会出现两次连结的过程，http协议本身不保存状态信息，一次请求一次响应。对于TCP而言，通信次数越多反而可靠性越低，能在一次连结中传输完需要的信息是最可靠的，所以尽量使用GET请求来减少网络耗时。如果通信时间增加，这段时间客户端于服务器端一直保持连接状态，在服务器侧负载可能会增加，可靠性会下降。
- GET请求能够被cache，GET请求能够被保存在浏览器的浏览历史里面（密码等重要数据GET提交，别人查看历史记录，就可以直接看到这些私密数据）POST不进行缓存。
- GET参数是带在URL后面，传统IE中URL的最大可用长度为2048字符，其他浏览器对URL长度限制实现上有所不同。POST请求无长度限制（目前理论上是这样）。
- GET提交的数据大小，不同浏览器的限制不同，一般在2k-8k之间，POST提交数据比较大，大小靠服务器的设定值限制，而且某些数据只能用POST方法【携带】，比如file。
- 全部用POST不是十分合理，最好先把请求按功能和场景分下类，对数据请求频繁，数据不敏感且数据量在普通浏览器最小限定的2k范围内，这种情况使用GET。其他地方使用POST。
- GET的本质是【得】，而POST的本质是【给】。而且，GET是【幂等】的，在这一点上，GET被认为是【安全的】。实际上server端也可以用作资源更新，但是这种用法违反了约定，容易造成CSRF（跨站请求伪造）。
## https
### http和https有什么区别
- https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。
- http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。
- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
### https过程
1. 客户端 => 服务器：使用的协议版本号；客户端生成的随机数；客户端支持的加密方法
2. 服务器 => 客户端：确认双方使用的加密方法；服务器的证书；服务器生成的随机数
3. 客户端 => 服务器：客户端生成的新随机数(预主密钥)并使用数字证书中的公钥加密；前面所有内容的 hash 值
4. 服务器 => 客户端：使用私钥解密客户端发送过来的随机数；提供前面所有内容的 hash 值
5. 服务器 <=> 客户端：根据约定的加密方法使用前面的三个随机数，生成对话秘钥；互相发送加密过的"finished"信号
6. 服务器 <=> 客户端：握手完成，双方使用对称加密进行安全通信。
### SSL的过程是什么
1. "client hello"消息：客户端通过发送"client hello"消息向服务器发起握手请求，该消息包含了客户端所支持的 TLS 版本和密码组合以供服务器进行选择，还有一个"client random"随机字符串。
2. "server hello"消息：服务器发送"server hello"消息对客户端进行回应，该消息包含了数字证书，服务器选择的密码组合和"server random"随机字符串。
3. 验证：客户端对服务器发来的证书进行验证，确保对方的合法身份，验证过程可以细化为以下几个步骤：
  - 检查数字签名
  - 验证证书链 (这个概念下面会进行说明)
  - 检查证书的有效期
  - 检查证书的撤回状态 (撤回代表证书已失效)
4. `premaster secret`字符串：客户端向服务器发送另一个随机字符串`premaster secret` (预主密钥)，这个字符串是经过服务器的公钥加密过的，只有对应的私钥才能解密。
5. 使用私钥：服务器使用私钥解密 `premaster secret`
6. 生成共享密钥：客户端和服务器均使用 `client random`，`server random` 和 `premaster secret`，并通过相同的算法生成相同的共享密钥 KEY。
7. 客户端就绪：客户端发送经过共享密钥 KEY 加密过的"finished"信号。
8. 服务器就绪：服务器发送经过共享密钥 KEY 加密过的"finished"信号。
9. 达成安全通信：握手完成，双方使用对称加密进行安全通信。
### TLS 握手
- RSA 握手
  1. 浏览器向服务器发送随机数 client_random，TLS 版本和供筛选的加密套件列表。
  2. 服务器接收到，立即返回 server_random，确认好双方都支持的加密套件以及数字证书 (证书中附带公钥 Public key certificate)。
  3. 浏览器接收，先验证数字证书。若通过，接着使用加密套件的密钥协商算法 RSA 算法生成另一个随机数 pre_random，并且用证书里的公钥加密，传给服务器。
  4. 服务器用私钥解密这个被加密后的 pre_random，参考 “非对称加密”。 
- DH 握手
- TLS1.2 握手
### 加密、数字签名与数字证书
- 加密：对明文数据按某种特殊算法进行处理，使其成为不可读的一段代码，通常称为“密文“， 密文通过”密钥“解密后还原出原来的明文，通过这样的途径可以达到保护数据不被非法人窃取、阅读的目的。
- 数字签名就是使用私钥对数据摘要进行签名，并附带和数据一起发送。
  - 可以起到防篡改、防伪装、防否认的作用。
  - 对数据的摘要进行签名，而不是直接计算原始数据的数字签名：数据可能比较大，签名是使用非对称加密算法，比较耗时，防止第三方使用公钥解开签名后，拿到原始数据
- 数字证书：公钥的数字签名
  - 引入数字证书的目的是为了保证公钥不被篡改，即使被篡改了也能识别出来。
  - CA 会将证书的颁布机构、有效期、公钥、持有者(subject)等信息用 CA 的私钥进行签名。
## HTTP 发展历程
- HTTP/0.9
  - 只有请求行
  - 仅支持GET
  - 一个请求需要一个连接。服务器发送完内容之后，就关闭TCP连接。
- HTTP/1.0
  - 增加了HEAD、POST等新方法
  - 增加了响应状态码，标记可能的错误原因
  - 引入了协议版本号概念
  - 引入了HTTP header的概念，让HTTP处理请求和响应更加灵活
  - 传输的数据不再局限于文本
## http2.0多路复用和长连接的区别
- HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接
- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，因为传输格式是文本的，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞
- HTTP/2多个请求可同时在一个连接上并行执行（由于支持二进制的格式，可以无序）某个请求任务耗时严重，不会影响到其它连接的正常执行
## HTTP 缓存
### Pragma 与 Expires
- Pragma 在响应报文中当该字段值为 "no-cache" 的时候，会通知客户端不要对该资源进行缓存，每次都得向服务器发一次请求才行。
- 有了 Pragma 来禁用缓存，那如果需要设置缓存的话就得有个东西来设置缓存的时间，对于 http 1.0 来说，Expires 就是做这件事的。
- Expires 的值对应一个 GMT (格林尼治时间)，比如 `Mon, 22 Mar 2017 11:12:01 GMT` 来告诉浏览器资源缓存过期时间，如果还没有超过该时间点则不发请求，直接返回 200 OK。(from cache)
- 没有有发送 http 请求, 它们都是直接读取缓存资源的。
- 缺点：
  - Expires 定义的缓存时间是相对于服务器上的时间而言的，而浏览器在判断的时候是基于客户端的系统时间的，如果用户修改了自己电脑的系统时间，那么这个缓存时间将没有任何意义。
  - 假如客户端上某个资源缓存时间过期了，但此时其实服务器并没有更新过该资源，那么这时候客户端要求服务器重新把东西再发送过来一遍，会浪费带宽和时间，这显然是不合理的，我们需要有一种正确的机制用来判断东西到底可以直接使用缓存。
### Cache-Control
- 它可以由多个可选值组合而成，可设定有效期
- 若报文中同时出现 Pragma、Expires 和 Cache-Control，那么会以 Cache-Control 为准。
### Last-Modified
- 为了解决前面遗留下的第二个问题，来保证当客户端上某个资源保存的缓存时间过期了，但这时候其实服务器并没有更新过这个资源，服务器能够正确处理这样的请求，而不是重新发送资源。
- 服务器将资源传递给客户端时，会将资源最后更改的时间以 "Last-Modified: GMT" 的形式加入到响应报头上一起返回给客户端。
- 如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而返回了整个实体给客户端
### Etag
- 服务器会通过某种算法，给资源计算得出一个唯一标志符(比如 md5 标志)，在把资源响应给客户端的时候，会在响应报文中加上 `Etag: 唯一标识符` 返回给客户端。客户端会保存该 Etag 字段，并在下次请求的时候将其作为请求头某字段的值发送请求，服务器只需要比较客户端传来的 Etag 跟自己服务器上该资源的 Etag 是否一致，就可以很好地判断资源相对客户端而言是否被修改过了。
- 如果 Last-Modified 和 ETag 同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。
- 缺点
  - 计算 Etag 值需要性能损耗;
  - 分布式服务器时依赖算法：分布式服务器存储的情况下，计算 Etag 的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时现 Etag 不匹配的情况。
### 优先级
## HTTP 与 WebSocket 的区别
- HTTP是单向的，客户端发送请求，服务器发送响应。WebSocket是双向的，在客户端-服务器通信的场景中使用的全双工协议
- HTTP是无状态协议；WebSocket是有状态协议
- HTTP可以运行在任何可靠的面向连接的协议（例如TCP，SCTP）的上层。
- 场景
  - 如果我们需要通过网络传输的任何实时更新或连续数据流，则可以使用WebSocket。
  - 如果仅加载一次数据，则RESTful Web服务足以从服务器获取数据。

# TCP
## TCP和UDP的区别是什么
- 基于连接与无连接；
- 对系统资源的要求（TCP较多，UDP少）；
- UDP程序结构较简单；
- 流模式与数据报模式；
  - udp面向数据报，每次传输都是一个一个数据包交付，不合并也不拆分，向下向上只是加首部和去首部的区别；
  - tcp是面向字节流的，简单说就是，应用程序和tcp交互每次一个数据块，但tcp只把这些看做是字节流，它不保证接受方收到的数据快的大小和发送方一样
- TCP保证数据正确性，UDP可能丢包；
- TCP保证数据顺序，UDP不保证。
- 比较
  - TCP 需要三次握手建立连接，四次挥手释放连接；UDP 不需要，面向无连接
  - TCP 首部需要 20 个字节；而 UDP 首部只有 8 个字节
  - TCP 具有一系列保证可靠传输的机制；而 UDP 尽最大努力交付，不提供可靠传输的机制，如果在数据传输的过程中出现部分数据的丢失，UDP 协议本身并不能做出任何检测或补救措施
  - 正是由于 UDP 没有了可靠传输机制，所以速度远远快于 TCP，在某些情况下 UDP 是一种最有效的工作方式，一般用于即时通信，比如：语音电话、 直播等等；而 TCP 一般用于文件传输、发送和接收邮件、远程登录等准确性要求比较高的场景
### 为什么 DNS 协议使用 UDP？只使用了 UDP 吗？
- DNS 并非只使用 UDP 协议，它同时占用了 UDP 和 TCP 的 53 端口
- TCP 是面向字节流的，而 UDP 是面向报文的，不做任何的拆分与合并，UDP 报文被限制在 512 字节以内。
- DNS 分别在什么情况下使用 UDP 和 TCP，了解了 TCP 面向字节流而 UDP 面向报文的这个特性之后，在域名解析的时候，也就是客户端向 DNS 服务器查询域名获取 IP 地址的时候，DNS 协议关于 UDP 和 TCP 的选择通常可以分为以下两种情况：
  - 若客户端事先知道 DNS 响应报文的长度会大于 512 字节，则应当直接使用 TCP 建立连接
  - 若客户端事先不知道 DNS 响应报文的长度，一般会先使用 UDP 协议发送 DNS 查询报文，若 DNS 服务器发现 DNS 响应报文的长度大于 512 字节，则多出来的部分会被 UDP 抛弃（截断 TrunCation），那么服务器会把这个部分被抛弃的 DNS 报文首部中的 TC 标志位置为 1，以通知客户端该 DNS 报文已经被截断。客户端收到之后会重新发起一次 TCP 请求，从而使得它将来能够从 DNS 服务器收到完整的响应报文。
  - 区域传输使用TCP，就是辅助域名服务器与主域名服务器通信，并同步数据信息的过程。
## TCP的流量控制的机制是什么？讲一下滑动窗口？
- TCP是一种可靠的数据传输协议，主要解决传输的可靠、有序、无丢失和不重复的问题。
- 慢开始算法: 在TCP刚连接好，开始发送TCP报文段时，先令拥塞窗口`cwnd=1`，在每收到一个对新的报文段确认后，再将`cwnd`加1，慢开始算法，每经过一个传输轮次（即往返RTT），拥塞窗口`cwnd`就会加倍，即呈指数形式增加，当慢开始算法把拥塞窗口`cwnd`增大到一个阈值`ssthresh`，改用拥塞避免算法。
- 拥塞避免算法: 拥塞避免算法的做法是：发送端的拥塞窗口`cwnd`每经过一个往返`RTT`，按线性规律缓慢增长。
- 快重传: 当发送方连续收到三个重复的ACK报文，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时。
- 快恢复: 当发送端收到连续三个冗余ACK时，就执行“乘法减少”算法，把慢开始阈值`ssthresh`设置为出现拥塞时发送方`cwnd`的一半。与慢开始将拥塞窗口`cwnd`设置为1的不同之处，它把`cwnd`的值设置为慢开始阈值`ssthresh`减半后的数值，然后执行拥塞避免算法，使拥塞窗口缓慢线性增大。
## 三次握手
- 三次握手，指的是在建立一个TCP连接时，需要客户端与服务端总共发送三个包
- 进行三次握手是为了确认双方发送接收能力是否正常。
- 实际上就是连接服务器指定端口，建立TCP连接，并同步连接双方序列号与确认号，交换TCP窗口大小信息
- 过程
  - 初始状态：客户端close，服务端listen
  - 第一次握手：客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。
  - 第二次握手：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。
  - 第三次握手：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。
  - 完成状态：均为ESTAB-LISTED
## 四次挥手
- TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。
- 过程
  - 第一次挥手：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。客户端变为FIN-WAIT1
  - 第二次挥手：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。客户端变为FIN-WAIT2
  - 第三次挥手：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。
  - 第四次挥手：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。
### 为什么等2MSL（最大段生存期）
- 最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。
### 什么时候也可以变成三次挥手？
- 延迟确认
- 防止通信过程中ack包满天飞，一般就是允许b方不立刻应答ack，可以等待b方给a方下一次发数据的时候一起带ack过去，这样传输效率高，这样的机制如果在四次挥手中触发，就有可能把第二次挥手的ack应答和第三次挥手的fin请求一起发过去，
- 简单来说就是第二次和第三次挥手合并了
## TCP粘包是怎么回事，如何处理
- 默认情况下, TCP 连接会启⽤延迟传送算法, 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送, 这样可以减少 IO 消耗提⾼性能.
- 如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包
## 为什么udp不会粘包
- TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据
- UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。
# WebSocket
- WebSocket是HTML5提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。
- 特点
  - 支持双向通信，实时性更强
  - 可以发送文本，也可以发送二进制数据
  - 建立在TCP协议之上，服务端的实现比较容易
  - 数据格式比较轻量，性能开销小，通信高效
  - 没有同源限制，客户端可以与任意服务器通信
  - 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL
  - 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
# DNS
## DNS 协议
- **概念**： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。
- **作用**： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。
## DNS域名解析
- 首先会在**浏览器的缓存**中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步
- 将请求发送给**本地DNS服务器**，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
- 本地DNS服务器向**根域名服务器**发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址
- 本地DNS服务器向**顶级域名服务器**发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
- 本地DNS服务器向**权威域名服务器**发送请求，域名服务器返回对应的结果
- 本地DNS服务器将返回结果保存在缓存中，便于下次使用
- 本地DNS服务器将返回结果返回给浏览器
# 输入url到页面渲染的过程
1. 输入URL地址
2. 浏览器进行DNS查询，查找域名对应的IP地址
   1. 浏览器在本地hosts文件中查找有没有对应的IP地址
   2. 发出一个DNS请求到本地DNS服务器
   3. 本地服务器查询缓存中是否存在对应关系，若有则返回，没有则向DNS根服务器查询
   4. DNS根服务器返回域名所在的域名服务器
   5. 本地DNS服务器向该域名服务器发出请求，域名服务器返回该域名的解析服务器的地址
   6. 本地DNS服务器向域名的解析服务器发出请求，收到该域名和IP地址的对应关系，保存到缓存并返回
3. 建立TCP连接，浏览器向web服务发送http请求
4. 服务器处理请求，并返回状态码和html文件
5. 浏览器判断状态码，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向发送另一个请求
6. 浏览器开始显示HTML。当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。
   1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。
   2. 将CSS解析成 CSS Rule Tree。
   3. 根据DOM树和`CSSOM`来构造 `Rendering Tree`。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了。
   4. 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。
   5. 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。
  - 注意点：上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。
7. 浏览器发送请求获取嵌入在HTML中的资源

# 网络安全
## XSS 攻击
- XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等
- XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。
- 类型
  - 存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。
  - 反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 
  - DOM 型指的通过修改页面的 DOM 节点形成的 XSS。
- 防御
  - 可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。
  - 使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。
  - 对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。
## CSRF 攻击
- CSRF 攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。
- CSRF 攻击的本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。
- 类型
  - GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。
  - POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。
  - 链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。
- 防御
  - 进行同源检测
  - 使用 CSRF Token 进行验证
  - 对 Cookie 进行双重验证
  - 在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用
## 中间人攻击
- 指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。
- 攻击过程
  - 客户端发送请求到服务端，请求被中间⼈截获
  - 服务器向客户端发送公钥
  - 中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个**伪造的**公钥，发给客户端
  - 客户端收到伪造的公钥后，⽣成加密hash值发给服务器
  - 中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器
  - 服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端
## 其它前端安全问题
- iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；
- 恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。
## 网络劫持有哪几种，如何防范
- ⽹络劫持分为两种:
  - **DNS劫持**: (输⼊京东被强制跳转到淘宝这就属于dns劫持)
    - DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器
    - 302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容
  - **HTTP劫持**: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)
- DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。
