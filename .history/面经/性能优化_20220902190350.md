## 前端性能指标
- 基本指标
  - 首屏绘制（First Paint，FP）
     - FP 是时间线上的第一个“时间点”，是指浏览器从响应用户输入网址地址，到浏览器开始显示内容的时间，简而言之就是浏览器第一次发生变化的时间。
  - 首屏内容绘制（First Contentful Paint，FCP）
    - FCP，是指浏览器从响应用户输入网络地址，在页面首次绘制文本，图片（包括背景图）、非白色的 canvas 或者SVG 才算做 FCP，有些文章说 FCP 是首屏渲染事件，这其实是不对的。
  - 可交互时间（Time to Interactive，TTI）
    - TTI，表示网页第一次完全达到可交互状态的时间点。可交互状态指的是页面上的 UI 组件是可以交互的（可以响应按钮的点击或在文本框输入文字等），不仅如此，此时主线程已经达到“流畅”的程度，主线程的任务均不超过50毫秒。在一般的管理系统中，TTI 是一个很重要的指标。
  - 最大内容绘制（Largest Contentful Paint，LCP)
    - LCP表示可视区“内容”最大的可见元素开始出现在屏幕上的时间点。
  - 首次有效绘制（First Meaning Paint, FMP）
    - FMP，表示页面的“主要内容”开始出现在屏幕上的时间点，它以前是我们测量用户加载体验的主要指标。本质上是通过一个算法来猜测某个时间点可能是 FMP，但是最好的情况也只有77%的准确率，在lighthouse6.0 的时候废弃掉了这个指标，取而代之的是 LCP 这个指标。
- 指标计算
  - 首屏和白屏
    - 白屏时间(First Paint)
      - 是指浏览器从响应用户输入网址地址，到浏览器开始显示内容（通常是显示背景色）的时间
      - 白屏会在页面加载之前触发，在这段时间里，不会呈现任何内容和信息给用户。虽然背景色会很快完成绘制，但是实际的内容和交互可能要花很长的时间去加载，因此，白屏时间过长，会让用户认为我们的页面不能用或可用性差。可以通过适当调整页面结构，来优化网页。
    - 首屏时间
      - 是指浏览器从响应用户输入网络地址，到首屏内容渲染完成的时间
      - 当页面绘制完第一个 DOM 内容，会触发首屏，这里的内容可以是文字、图片或者是 canvas。
## 工程上的性能指标
- 移动端：FPS、CPU使用率、内存占用、卡顿、页面加载时间、网络请求流量
- wen端：页面加载时间、全部页面加载时间、首字节时间、DNS时间、TCP时间、页面渲染、下载速度、页面流畅度、网络丢包率、网络时延、请求响应时间、事务响应时间、并发用户数等
## 优化
- 减少HTTP请求
- 使用CDN
  - CDN，内容分发网络，是构建在现有互联网基础之上的一层智能虚拟网络，通过在网络各处部署节点服务器，实现将源站内容分发至所有CDN节点，使用户可以就近获得所需的内容。CDN服务缩短了用户查看内容的访问延迟，提高了用户访问网站的响应速度与网站的可用性，解决了网络带宽小、用户访问量大、网点分布不均等问题。
  - 原理: 当用户访问使用CDN服务的网站时，本地DNS服务器通过CNAME方式将最终域名请求重定向到CDN服务。CDN通过一组预先定义好的策略(如内容类型、地理区域、网络负载状况等)，将当时能够最快响应用户的CDN节点IP地址提供给用户，使用户可以以最快的速度获得网站内容。使用CDN后的HTTP请求处理流程如下
- 添加Expires头：通过使用一个长久的Expires头，可以使这些组件被缓存，下次访问的时候，就可以减少不必要的HTPP请求，从而提高加载速度。
- 压缩组件
- 将样式表放在头部：
  - 将样式表放在头部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现，改善用户体验，防止“白屏”。
  - 将样式表放在文档底部会阻止浏览器中的内容逐步出现。为了避免当样式变化时重绘页面元素，浏览器会阻塞内容逐步呈现，造成“白屏”。这源自浏览器的行为：如果样式表仍在加载，构建呈现树就是一种浪费，因为所有样式表加载解析完毕之前务虚会之任何东西
- 将脚本放在底部
  - 脚本放在底部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现。
  - js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。
- 避免CSS表达式
- 使用外部的JavaScript和CSS
  - 内联脚本或者样式可以减少HTTP请求，按理来说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存它们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小，从而提高加载速度。
  - 每个用户产生的页面浏览量越少，内联脚本和样式的论据越强势。譬如一个用户每个月只访问你的网站一两次，那么这种情况下内联将会更好。而如果该用户能够产生很多页面浏览量，那么缓存的样式和脚本将会极大减少下载的时间，提交页面加载速度
- 减少DNS查找
- 精简JavaScript CSS
- 避免重定向
- 删除重复脚本
- 配置ETag
  - 如果使用Last-Modified不会出现任何问题，可以直接移除ETag，google的搜索首页则没有使用ETag。
  - 确定要使用ETag，在配置ETag的值的时候，移除可能影响到组件集群服务器验证的属性，例如使用size-timestamp来生成时间戳。
## CDN 流程
1. 用户在浏览器输入要访问的网站域名，向本地DNS发起域名解析请求。
2. 域名解析的请求被发往网站授权DNS服务器。
3. 网站DNS服务器解析发现域名已经CNAME到了www.example.com.c.cdnhwc1.com。
4. 请求被指向CDN服务。
5. CDN对域名进行智能解析，将响应速度最快的CDN节点IP地址返回给本地DNS。
6. 用户获取响应速度最快的CDN节点IP地址。
7. 浏览器在得到速度最快节点的IP地址以后，向CDN节点发出访问请求。
8. CDN节点将用户所需资源返回给用户。
## 使用 Preload/Prefetch 优化
- preload 提前加载
  - preload 顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用的时候立即执行，就无需等待网络的消耗。
- prefetch 预判加载
  - prefetch 跟 preload 不同，它的作用是告诉浏览器未来可能会使用到的某个资源，浏览器就会在闲时去加载对应的资源，若能预测到用户的行为，比如懒加载，点击到其它页面等则相当于提前预加载了需要的资源。
- 当一个资源被 preload 或者 prefetch 获取后，它将被放在内存缓存中等待被使用，如果资源位存在有效的缓存机制（如 cache-control 或 max-age），它将被存储在 HTTP 缓存中可以被不同页面所使用。
- 正确使用 preload/prefetch 不会造成二次下载，也就说：当页面上使用到这个资源时候 preload 资源还没下载完，这时候不会造成二次下载，会等待第一次下载并执行脚本。
- 对于 preload 来说，一旦页面关闭了，它就会立即停止 preload 获取资源，而对于 prefetch 资源，即使页面关闭，prefetch 发起的请求仍会进行不会中断。

## 多域名储存
- 利用多域名存储静态资源进行性能优化：网站的静态资源为什么要使用独立域名
- 浏览器并发请求数的限制
  - 大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。
  - 浏览器对并发请求的数目限制是针对域名的，即针对同一域名（包括二级域名）在同一时间支持的并发请求数量的限制。如果请求数目超出限制，则会阻塞。因此，网站中对一些静态资源，使用不同的一级域名，可以提升浏览器并行请求的数目，加速界面资源的获取速度。
  - 过多的域名会使DNS解析负担加重，因此一般控制在2-4个。
  - 对于图片资源的加载，利用css sprites技术，结合background的定位在同一张图片中加载多个图片，这也是减少并发数量的一种常用方法。
- 网络请求时cookie传输
  - 当静态资源与主服务在同一域名下（根据业务需要，主服务请求时需要传递cookie信息），每次静态资源的请求，都会发送同域名下的cookie。而对于静态资源，服务器无需对cookie进行任何处理，它们只是在毫无意义的消耗带宽。
  - 对于静态资源使用单独的域名，并设置为无cookie，以减少请求大小，提高网页性能。
- 方便分流或缓存
  - 当面对大并发访问时，在服务端会有相应的缓存机制
  - 独立的域名也方便我们在代理服务层做动静分离，以便提升静态请求的处理速度。

## 前端常见的攻击和防御方法
- Cookie挟持
  - 危害：盗取cookie信息，冒充他人身份，盗取信息。
  - 防御
    - 给cookie添加HttpOnly属性，该属性设置后，只能在http请求中传递，在脚本中，document.cookie无法获取到该cookie值（即js无法读取cookie，服务器端是可以照常获得的），对XSS攻击有防御作用，但对网络拦截还是会泄露。
    - 在cookie中添加校验信息，这个校验信息和当前用户外置环境有些关系，比如ip、user agent等有关.这样当cookie被人劫持冒用时，在服务器端校验的时候，发现校验值发生了变化，因此会要求用户重新登录，可以规避cookie劫持。
    - cookie中session id的定时更换，让session id按一定频率变换，同时对用户而言，该操作是透明的，这样保证了服务体验的一致性。
- XSS跨站脚本攻击：攻击者在web页面恶意插入HTML或script标签，当用户浏览该页面时，恶意代码就会被执行，从而达到攻击的目的。XSS利用的是用户对指定网站的信任。
  - 类型
    - 反射型(非持久)：攻击者事先制作好攻击链接,需要欺骗用户自己去点击链接才能触发XSS代码，所谓反射型XSS就是将恶意用户输入的js脚本，反射到浏览器执行。
    - 储存型(持久型)：会把攻击者的数据储存到服务端，攻击行为将伴随攻击数据一直存在，每当用户访问该页面就会触发代码执行。
    - DOM型：基于文档对象模型的漏洞。
  - 危害
    - 盗取网页浏览中的cookie值，盗用cookie实现无密码登录，盗取用户信息。
    - 劫持访问，实现恶意跳转。
    - 配合CSRF攻击完成恶意请求。
  - 防御
    - 标签过滤，如`<script>`、`<img>`、`<a>`标签等
    - 编码，对字符< 、>、&、" 、' 、+、/等进行转义。
    - cookie防盗，将cookie设置为http-only,js脚本将无法读取到cookie信息。
    - 纯前端渲染，明确innerText、setAttribute、style，将代码与数据分隔开。
    - 避免不可信的数据拼接到字符串中传递给这些API，如DOM中的内联事件监听器，location、onclick、onload、onmouseover等，`<a>`标签的href属性，JavaScript的eval()、setTimeout()、setInterval()等，都能把字符串作为代码运行
- CSRF跨站点请求伪造: 通过伪造连接请求，在用户不知情的情况下，让用户以自己的身份来完成非本意操作的攻击方法。CSRF利用的是网站对浏览器的信任。
  - 原理
    - 用户C浏览并登录信任网站A,产生cookie
    - 用户C未退出网站A，在同一个浏览器危险访问网站B
    - 网站B的页面存有一些攻击性的代码，会发出访问A的请求
    - 浏览器收到请求后，在用户不知情的情况下携带cookie访问网站A
    - A不知道请求是谁发的，浏览器会带上用户的cookie，所以A会根据用户的权限处理B发出的请求。这样就达到了攻击的目的。
  - 防御
    - 验证码：对敏感操作加入验证码，强制用户与网站进行交互
    - 对Cookie设置SameSite属性。该属性表示Cookie不随着跨域请求发送，可以很大程度减少CSRF的攻击，但是该属性目前并不是所有浏览器都兼容。
    - 使用POST请求，避免使用GET，降低攻击风险，post请求攻击方需要构造一个form表单才可以发起请求，比get请求（img的src，a标签的href等等）的攻击方式复杂了一些，相对来说能降低风险，但不能阻止。
    - 检查HTTP中的referer字段，该字段记录了HTTP请求的来源地址
    - 在请求头中加入token验证字段，浏览器并不会自动携带Token去请求，且Token可以携带一段加密的jwt用作身份认证，这样进行CSRF的时候仅传递了cookie，并不能表明用户身份，网站即拒绝攻击请求。
    - 在http中自定义属性并验证。
- 点击挟持
  - 分类
    - ClickJacking点击劫持: 当访问某网站时，利用CSS将攻击者实际想让你点击的页面进行透明化隐藏，然后在页面后显示 一些东西诱导让你点击，点击后则会在用户毫不知情的情况下做了某些操作，这就是点击劫持ClickJacking。
    - iframe覆盖: 第三方网站通过iframe内嵌某一个网站，并且将iframe设置为透明不可见，将其覆盖在其他经过伪装的DOM上，伪装的可点击DOM（按钮等）与实际内嵌网站的可点击DOM位置相同，当用户点击伪装的DOM时，实际上点击的是iframe中内嵌的网页的DOM从而触发请求操作。
  - 防御
    - Javascript禁止内嵌
    - 设置http响应头X-FRAME-OPTIONS是目前最可靠的方法
- 中间人攻击
- URL漏洞跳转
- SQL注入
- OS命令注入攻击

# 移动端
## 移动端兼容性问题及解决方案
### IOS上click点击事件会有300ms的延迟响应
- 换用zepto的touch模块，tap事件也是为了解决在click的延迟问题
- 或者引入fastclick.js解决
### 移动端页面滚动滞涩感
- css在body元素上添加-webkit-overflow-scrolling: touch;
### 软键盘与输入框问题
- h5页面有个问题就是，当输入框在最底部，点击软键盘后输入框会被遮挡
### 阻止旋转屏幕时自动调整字体大小
### 移动端某些情况下input的placeholder会出现文本位置偏上的现象
- PC端设置line-height等于height能够对齐，而移动端仍然是偏上，解决是设置line-height：normal
