## 优化
- 减少HTTP请求
- 使用CDN
- 添加Expires头：通过使用一个长久的Expires头，可以使这些组件被缓存，下次访问的时候，就可以减少不必要的HTPP请求，从而提高加载速度。
- 压缩组件
- 将样式表放在头部：
  - 将样式表放在头部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现，改善用户体验，防止“白屏”。
  - 将样式表放在文档底部会阻止浏览器中的内容逐步出现。为了避免当样式变化时重绘页面元素，浏览器会阻塞内容逐步呈现，造成“白屏”。这源自浏览器的行为：如果样式表仍在加载，构建呈现树就是一种浪费，因为所有样式表加载解析完毕之前务虚会之任何东西
- 将脚本放在底部
  - 脚本放在底部对于实际页面加载的时间并不能造成太大影响，但是这会减少页面首屏出现的时间，使页面内容逐步呈现。
  - js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。
- 避免CSS表达式
- 使用外部的JavaScript和CSS
  - 内联脚本或者样式可以减少HTTP请求，按理来说可以提高页面加载的速度。然而在实际情况中，当脚本或者样式是从外部引入的文件，浏览器就有可能缓存它们，从而在以后加载的时候能够直接使用缓存，而HTML文档的大小减小，从而提高加载速度。
  - 每个用户产生的页面浏览量越少，内联脚本和样式的论据越强势。譬如一个用户每个月只访问你的网站一两次，那么这种情况下内联将会更好。而如果该用户能够产生很多页面浏览量，那么缓存的样式和脚本将会极大减少下载的时间，提交页面加载速度
- 减少DNS查找
- 精简JavaScript CSS
- 避免重定向
- 删除重复脚本
## 使用 Preload/Prefetch 优化
- preload 提前加载
  - preload 顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用的时候立即执行，就无需等待网络的消耗。
- prefetch 预判加载
  - prefetch 跟 preload 不同，它的作用是告诉浏览器未来可能会使用到的某个资源，浏览器就会在闲时去加载对应的资源，若能预测到用户的行为，比如懒加载，点击到其它页面等则相当于提前预加载了需要的资源。
- 当一个资源被 preload 或者 prefetch 获取后，它将被放在内存缓存中等待被使用，如果资源位存在有效的缓存机制（如 cache-control 或 max-age），它将被存储在 HTTP 缓存中可以被不同页面所使用。
- 正确使用 preload/prefetch 不会造成二次下载，也就说：当页面上使用到这个资源时候 preload 资源还没下载完，这时候不会造成二次下载，会等待第一次下载并执行脚本。
- 对于 preload 来说，一旦页面关闭了，它就会立即停止 preload 获取资源，而对于 prefetch 资源，即使页面关闭，prefetch 发起的请求仍会进行不会中断。

## 多域名储存
- 利用多域名存储静态资源进行性能优化：网站的静态资源为什么要使用独立域名
- 浏览器并发请求数的限制
  - 大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。
  - 浏览器对并发请求的数目限制是针对域名的，即针对同一域名（包括二级域名）在同一时间支持的并发请求数量的限制。如果请求数目超出限制，则会阻塞。因此，网站中对一些静态资源，使用不同的一级域名，可以提升浏览器并行请求的数目，加速界面资源的获取速度。
  - 过多的域名会使DNS解析负担加重，因此一般控制在2-4个。
  - 对于图片资源的加载，利用css sprites技术，结合background的定位在同一张图片中加载多个图片，这也是减少并发数量的一种常用方法。
- 网络请求时cookie传输
  - 当静态资源与主服务在同一域名下（根据业务需要，主服务请求时需要传递cookie信息），每次静态资源的请求，都会发送同域名下的cookie。而对于静态资源，服务器无需对cookie进行任何处理，它们只是在毫无意义的消耗带宽。
  - 对于静态资源使用单独的域名，并设置为无cookie，以减少请求大小，提高网页性能。
- 方便分流或缓存
  - 当面对大并发访问时，在服务端会有相应的缓存机制
  - 独立的域名也方便我们在代理服务层做动静分离，以便提升静态请求的处理速度。

## 前端常见的攻击和防御方法
- Cookie挟持
  - 危害：盗取cookie信息，冒充他人身份，盗取信息。
  - 防御
    - 给cookie添加HttpOnly属性，该属性设置后，只能在http请求中传递，在脚本中，document.cookie无法获取到该cookie值，对XSS攻击有防御作用，但对网络拦截还是会泄露。
    - 在cookie中添加校验信息，这个校验信息和当前用户外置环境有些关系，比如ip、user agent等有关.这样当cookie被人劫持冒用时，在服务器端校验的时候，发现校验值发生了变化，因此会要求用户重新登录，可以规避cookie劫持。
    - cookie中session id的定时更换，让session id按一定频率变换，同时对用户而言，该操作是透明的，这样保证了服务体验的一致性。
- XSS跨站脚本攻击：攻击者在web页面恶意插入HTML或script标签，当用户浏览该页面时，恶意代码就会被执行，从而达到攻击的目的。XSS利用的是用户对指定网站的信任。
  - 类型
    - 反射型(非持久)：攻击者事先制作好攻击链接,需要欺骗用户自己去点击链接才能触发XSS代码，所谓反射型XSS就是将恶意用户输入的js脚本，反射到浏览器执行。
    - 储存型(持久型)：会把攻击者的数据储存到服务端，攻击行为将伴随攻击数据一直存在，每当用户访问该页面就会触发代码执行。
    - DOM型：基于文档对象模型的漏洞。
  - 危害
    - 盗取网页浏览中的cookie值，盗用cookie实现无密码登录，盗取用户信息。
    - 劫持访问，实现恶意跳转。
    - 配合CSRF攻击完成恶意请求。
  - 防御
    - 标签过滤，如`<script>`、`<img>`、`<a>`标签等
    - 编码，对字符< 、>、&、" 、' 、+、/等进行转义。
    - cookie防盗，将cookie设置为http-only,js脚本将无法读取到cookie信息。
    - 纯前端渲染，明确innerText、setAttribute、style，将代码与数据分隔开。
    - 避免不可信的数据拼接到字符串中传递给这些API，如DOM中的内联事件监听器，location、onclick、onload、onmouseover等，`<a>`标签的href属性，JavaScript的eval()、setTimeout()、setInterval()等，都能把字符串作为代码运行
- CSRF跨站点请求伪造: 通过伪造连接请求，在用户不知情的情况下，让用户以自己的身份来完成非本意操作的攻击方法。CSRF利用的是网站对浏览器的信任。
  - 原理
    - 用户C浏览并登录信任网站A,产生cookie
    - 用户C未退出网站A，在同一个浏览器危险访问网站B
    - 网站B的页面存有一些攻击性的代码，会发出访问A的请求
    - 浏览器收到请求后，在用户不知情的情况下携带cookie访问网站A
    - A不知道请求是谁发的，浏览器会带上用户的cookie，所以A会根据用户的权限处理B发出的请求。这样就达到了攻击的目的。
  - 防御
    - 验证码：对敏感操作加入验证码，强制用户与网站进行交互
    - 对Cookie设置SameSite属性。该属性表示Cookie不随着跨域请求发送，可以很大程度减少CSRF的攻击，但是该属性目前并不是所有浏览器都兼容。
    - 使用POST请求，避免使用GET，降低攻击风险，post请求攻击方需要构造一个form表单才可以发起请求，比get请求（img的src，a标签的href等等）的攻击方式复杂了一些，相对来说能降低风险，但不能阻止。
    - 检查HTTP中的referer字段，该字段记录了HTTP请求的来源地址
    - 在请求头中加入token验证字段，浏览器并不会自动携带Token去请求，且Token可以携带一段加密的jwt用作身份认证，这样进行CSRF的时候仅传递了cookie，并不能表明用户身份，网站即拒绝攻击请求。
    - 在http中自定义属性并验证。
- 点击挟持
  - 分类
    - ClickJacking点击劫持: 当访问某网站时，利用CSS将攻击者实际想让你点击的页面进行透明化隐藏，然后在页面后显示 一些东西诱导让你点击，点击后则会在用户毫不知情的情况下做了某些操作，这就是点击劫持ClickJacking。
    - iframe覆盖: 第三方网站通过iframe内嵌某一个网站，并且将iframe设置为透明不可见，将其覆盖在其他经过伪装的DOM上，伪装的可点击DOM（按钮等）与实际内嵌网站的可点击DOM位置相同，当用户点击伪装的DOM时，实际上点击的是iframe中内嵌的网页的DOM从而触发请求操作。
  - 防御
    - Javascript禁止内嵌
    - 设置http响应头X-FRAME-OPTIONS是目前最可靠的方法
- 中间人攻击
- URL漏洞跳转
- SQL注入
- OS命令注入攻击

